import Mathlib
import WhitneyGraustein.calculus


open Set Function Complex Real Order

open Topology NormedSpace

open Mathlib



noncomputable section

structure CircleImmersion (Œ≥ : ‚Ñù ‚Üí ‚ÑÇ) : Prop where
  diff : ContDiff ‚Ñù ‚ä§ Œ≥
  per : Periodic Œ≥ 1
  deriv_ne : ‚àÄ t, deriv Œ≥ t ‚â† 0

/-
def CircleImmersion.lift {Œ≥ : ‚Ñù ‚Üí ‚ÑÇ} (imm_Œ≥ : CircleImmersion Œ≥) : ‚Ñù ‚Üí ‚Ñù := sorry

lemma lift_exists {Œ≥ : ‚Ñù ‚Üí ‚ÑÇ} (imm_Œ≥ : CircleImmersion Œ≥) :
  ‚àÉ Œ∏ : ‚Ñù ‚Üí ‚Ñù, (Œ∏ = CircleImmersion.lift imm_Œ≥) ‚àß (ContDiff ‚Ñù ‚ä§ Œ∏) ‚àß (‚àÄ (t : ‚Ñù), (deriv Œ≥ t = ‚Äñderiv Œ≥ t‚Äñ * exp (I * Œ∏ t))) := sorry
-/

axiom CircleImmersion.lift {Œ≥ : ‚Ñù ‚Üí ‚ÑÇ} (imm_Œ≥ : CircleImmersion Œ≥) : ‚Ñù ‚Üí ‚Ñù

-- Lift unique?


variable {Œ≥ : ‚Ñù ‚Üí ‚ÑÇ} (imm_Œ≥ : CircleImmersion Œ≥)

axiom CircleImmersion.contDiff_lift : ContDiff ‚Ñù ‚ä§ imm_Œ≥.lift

axiom CircleImmersion.deriv_eq (t : ‚Ñù) : deriv Œ≥ t = ‚Äñderiv Œ≥ t‚Äñ * Complex.exp (I * imm_Œ≥.lift t)

axiom CircleImmersion.turningNumber {Œ≥ : ‚Ñù ‚Üí ‚ÑÇ} (imm_Œ≥ : CircleImmersion Œ≥) : ‚Ñ§

axiom CircleImmersion.lift_add (t : ‚Ñù) (k : ‚Ñ§) : imm_Œ≥.lift (t + k) = imm_Œ≥.lift t + k*imm_Œ≥.turningNumber*2*œÄ





structure HtpyCircleImmersion (Œ≥ : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚ÑÇ) : Prop where
  diff : ContDiff ‚Ñù ‚ä§ (uncurry Œ≥)
  imm : ‚àÄ s, CircleImmersion (Œ≥ s)

/-
‚àÄK‚ÇÅ, K‚ÇÇ, K‚ÇÉ : ‚Ñù, with K‚ÇÅ > 0, and ‚àÄH > 0, we claim that  there exists some N‚ÇÄ such that N ‚â• N‚ÇÄ
implies that K‚ÇÅHN - K‚ÇÇH - K‚ÇÉ > 0

This is required to construct our gamma function and for the main phase.
-/

lemma root_lemma_maybe {H : ‚Ñù} (K‚ÇÅ : ‚Ñù) (K‚ÇÇ : ‚Ñù) (K‚ÇÉ : ‚Ñù) (K‚ÇÅ_pos : K‚ÇÅ > 0) (H_pos : H > 0) : ‚àÉ (N‚ÇÄ : ‚Ñï), ‚àÄ N > N‚ÇÄ, (K‚ÇÅ * H) * N - (K‚ÇÇ * H + K‚ÇÉ) > 0 := by
  let K‚ÇÅH_pos := Real.mul_pos K‚ÇÅ_pos H_pos
  /- Claim that N‚ÇÄ = max (‚åä(K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H) + 1‚åã) (0)

  Note that:
  N‚ÇÄ > (K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H)
  ‚Üî K‚ÇÅ*HN > K‚ÇÉ + K‚ÇÇ * H
  ‚Üî  K‚ÇÅ*HN - K‚ÇÇ * H -  K‚ÇÉ > 0
  -/
  let N‚ÇÄ := Nat.floor (max ((K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H) + 1) (0) )
  use N‚ÇÄ
  intro N hN

  have apply_floor_lt :=
    (Nat.floor_lt (le_max_right ((K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H) + 1) 0)).1 (gt_iff_lt.1 hN)

  have context: (K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H) + 1 ‚â§ max ((K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H) + 1) 0 := by
    exact le_max_left ((K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H) + 1) 0

  have final: (K‚ÇÉ + K‚ÇÇ * H) / (K‚ÇÅ * H) < N := by linarith
  have final2: (K‚ÇÉ + K‚ÇÇ * H) < (K‚ÇÅ * H) * N  := by exact (div_lt_iff' K‚ÇÅH_pos).mp final
  linarith

namespace WhitneyGraustein

@[reducible] def unit : Set ‚Ñù := Set.Icc 0 1
@[reducible] def ruffling : Set ‚Ñù := Set.Icc 0 (1/4:‚Ñù)
@[reducible] def unruffling : Set ‚Ñù := Set.Icc (3/4:‚Ñù) 1
@[reducible] def main : Set ‚Ñù := Set.Icc (1/4:‚Ñù) (3/4:‚Ñù)
@[reducible] def antimain : Set ‚Ñù := (Set.Iic 0) ‚à™ (Set.Ici 1)

section phases

lemma ruffling_closed : IsClosed (Set.Icc 0 (1/4:‚Ñù)) := isClosed_Icc
lemma unruffling_closed : IsClosed (Set.Icc (3/4:‚Ñù) 1) := isClosed_Icc
lemma main_closed : IsClosed (Set.Icc (1/4:‚Ñù) (3/4:‚Ñù)) := isClosed_Icc

lemma ruffling_unruffling_disjoint : Disjoint ruffling unruffling := by
  intro S hS hS'
  by_contra opp
  push_neg at opp

  rcases (not_forall_not.mp opp) with ‚ü®x,hx‚ü©
  specialize hS hx
  specialize hS' hx
  rcases hS with ‚ü®_,B‚ü©
  rcases hS' with ‚ü®C,_‚ü©
  have fact : (1/4:‚Ñù) < (3/4:‚Ñù) := by norm_num
  have fact2 : x < (3/4:‚Ñù)  := LE.le.trans_lt B fact
  linarith

lemma main_antimain_disjoint : Disjoint main antimain := by
  intro S hS hS'
  by_contra opp
  push_neg at opp

  rcases (not_forall_not.mp opp) with ‚ü®x,hx‚ü©
  specialize hS hx
  specialize hS' hx
  rcases hS with ‚ü®A,B‚ü©
  rcases hS' with C|D

  simp at C
  linarith
  simp at D
  linarith

lemma unit_compact : IsCompact unit := isCompact_Icc
lemma unit_nonempty : Set.Nonempty unit := nonempty_of_nonempty_subtype

end phases



section triangle_inequalities

lemma triangle' {A B : ‚ÑÇ} : ‚ÄñB‚Äñ ‚â§ ‚ÄñA + B‚Äñ + ‚ÄñA‚Äñ := by
  have fact := norm_add_le (A+B) (-A)
  simp at fact
  exact fact

lemma triangle {A B : ‚ÑÇ} : ‚ÄñB‚Äñ - ‚ÄñA‚Äñ ‚â§ ‚ÄñA + B‚Äñ :=
  tsub_le_iff_right.mpr triangle'

lemma in_particular {A B C : ‚ÑÇ} : ‚ÄñC‚Äñ - ‚ÄñB‚Äñ - ‚ÄñA‚Äñ ‚â§ ‚ÄñA + B + C‚Äñ :=
  calc
    ‚ÄñC‚Äñ - ‚ÄñB‚Äñ - ‚ÄñA‚Äñ ‚â§ ‚ÄñB + C‚Äñ - ‚ÄñA‚Äñ := sub_le_sub_right triangle ‚ÄñA‚Äñ
    _ ‚â§ ‚ÄñA + (B + C)‚Äñ := triangle
    _ = ‚ÄñA + B + C‚Äñ := congrArg Norm.norm (add_assoc A B C).symm

end triangle_inequalities





section coer_properties


lemma coer_deriv : ‚àÄ t:‚Ñù, deriv (fun (x:‚Ñù) ‚Ü¶ (x:‚ÑÇ)) t = 1 := by
  intro t
  have id_deriv : HasDerivAt (fun (x:‚ÑÇ)‚Ü¶ (x:‚ÑÇ)) 1 t := by exact hasDerivAt_id' ((‚Üët):‚ÑÇ)
  have hda_main := HasDerivAt.comp_ofReal id_deriv
  exact HasDerivAt.deriv hda_main


/-Credit: Kevin Buzzard-/
lemma coer_diff : ContDiff ‚Ñù ‚ä§ fun (x:‚Ñù) ‚Ü¶ (x:‚ÑÇ) :=
  ContinuousLinearMap.contDiff ofRealClm

end coer_properties





section H

def H : ‚Ñù := 1

lemma H_pos : 0 < H := Real.zero_lt_one

def h : ‚Ñù ‚Üí ‚Ñù := sorry

lemma h_diff : ContDiff ‚Ñù ‚ä§ h  := sorry

lemma h_main : ‚àÄ·∂† (x : ‚Ñù) in ùìùÀ¢ main, h x = 0 := sorry

lemma h_antimain : ‚àÄ·∂† (x : ‚Ñù) in ùìùÀ¢ antimain, h x = H := sorry

lemma h_mem : ‚àÄ (x : ‚Ñù), h x ‚àà Icc 0 1 := sorry

@[simp] lemma h_zero : h 0 = 0 := sorry

@[simp] lemma h_one : h 1 = 0 := sorry

end H





section ruffle

variable (N:‚Ñï)

def ruffle : ‚Ñù ‚Üí ‚ÑÇ := fun t ‚Ü¶ ‚ü®-Real.sin (4 * œÄ * t), 2 * Real.sin (2 * œÄ * t)‚ü©

lemma duh : ruffle = (fun x:‚Ñù ‚Ü¶ -Real.sin (4 * œÄ * x)+ (2 * Real.sin (2 * œÄ * x))‚Ä¢I) := by
  ext x
  unfold ruffle
  dsimp
  have fact (y:‚ÑÇ) : y=y.re + y.im ‚Ä¢ I := by
    simp
  specialize fact (ruffle x)
  unfold ruffle at fact
  dsimp at fact
  rw [fact]
  simp





lemma ruffle_deriv_neq_zero_on_unit{t:‚Ñù}(ht: t ‚àà unit): deriv ruffle t ‚â† 0 := by
  rw[duh]

  intro opp

  rw [deriv_add] at opp
  rw [deriv.neg] at opp

  have : (fun (x:‚Ñù) ‚Ü¶ ‚Üë(Real.sin (4 * œÄ * x))) = (fun (x:‚Ñù)‚Ü¶ (x:‚ÑÇ)) ‚àò (fun (y:‚Ñù) ‚Ü¶ Real.sin (4 * œÄ * y)) := by exact rfl
  rw [this] at opp
  clear this
  rw [deriv.comp] at opp


  have : ‚àÄ k:‚Ñù, (deriv (fun (x:‚Ñù) ‚Ü¶ k * x) t ) = k * deriv (fun (x:‚Ñù) ‚Ü¶ x) t:= by
    intro k
    apply deriv_const_mul
    exact differentiableAt_id'
  specialize this (4*œÄ)
  rw [this] at opp
  clear this
  simp only [deriv_id'', mul_one, real_smul, ofReal_sin,
    deriv_mul_const_field', deriv_const_mul_field'] at opp
  push_cast at opp
  rw [deriv_const_mul] at opp

  have : (fun (x:‚Ñù) ‚Ü¶ Complex.sin (2 * ‚ÜëœÄ * ‚Üëx)) = Complex.sin ‚àò (fun (x:‚Ñù) ‚Ü¶ (2 * ‚ÜëœÄ * ‚Üëx)) := by exact rfl
  rw [this] at opp
  rw [deriv.comp] at opp
  rw [Complex.deriv_sin] at opp
  clear this
  rw [deriv_mul] at opp
  rw [deriv_const, zero_mul, zero_add] at opp
  rw [coer_deriv t, mul_one] at opp
  sorry


  sorry
  sorry
  sorry
  sorry
  sorry
  sorry
  sorry


  /-TODO!!!!!! -/




lemma ruffle_diff : ContDiff ‚Ñù ‚ä§ ruffle := by

  rw [duh]
  apply ContDiff.add
  apply ContDiff.neg
  -- This statements make the composition explicit so ContDiff.comp can work
  have : (fun x ‚Ü¶ ‚Üë(Real.sin (4 * œÄ * x))) = (fun (y:‚Ñù) ‚Ü¶(y:‚ÑÇ)) ‚àò (fun x ‚Ü¶ Real.sin (4 * œÄ * x)) := by
    exact rfl
  rw [this]
  apply ContDiff.comp
  exact coer_diff

  --same as previous
  have : (fun x ‚Ü¶ Real.sin (4 * œÄ * x) )= Real.sin ‚àò (fun x ‚Ü¶ (4 * œÄ * x)) := by
    exact rfl
  rw[this]
  apply ContDiff.comp
  exact Real.contDiff_sin
  apply ContDiff.mul
  exact contDiff_const
  exact contDiff_id


  apply ContDiff.smul
  apply ContDiff.mul
  exact contDiff_const
  --same as previous
  have : (fun x ‚Ü¶ Real.sin (2 * œÄ * x) )= Real.sin ‚àò (fun x ‚Ü¶ (2 * œÄ * x)) := by
    exact rfl
  rw[this]

  apply ContDiff.comp
  exact Real.contDiff_sin
  apply ContDiff.mul
  exact contDiff_const
  exact contDiff_id

  exact contDiff_const



lemma p_ruffle : Periodic (fun x ‚Ü¶ ruffle (N * x)) 1 := by
          intro x
          simp
          unfold ruffle
          simp
          constructor
          have : Real.sin (4 * œÄ * (N * (x + 1))) = Real.sin (4 * œÄ * (N * x ) + 4 * œÄ * N) := by
            ring_nf

          rw [this]

          have : ‚àÄ k: ‚Ñï, Real.sin (4 * œÄ * (k * x ) + 4 * œÄ * k) = Real.sin (4 * œÄ * (k * x )) := by
            intro k
            have fact2 := Function.Periodic.nat_mul Real.sin_periodic (2*k)
            specialize fact2 (4 * œÄ * (‚Üëk * x))
            simp at fact2
            have : 2 * ‚Üëk * (2 * œÄ) = 4 * œÄ * k := by ring
            rw [this] at fact2
            rw [fact2]
          specialize this N
          push_cast at this

          rw [this]

          have : Real.sin (2 * œÄ * (N * (x + 1))) = Real.sin (2 * œÄ * (N * x) + 2 * œÄ * N) := by
            ring_nf

          rw [this]

          have : ‚àÄ k : ‚Ñï, Real.sin (2 * œÄ * (k * x) + 2 * œÄ * k) = Real.sin (2 * œÄ * (k * x)) := by
            intro k
            have fact := Real.sin_periodic
            have fact2 := Function.Periodic.nat_mul fact (k)
            specialize fact2 (2 * œÄ * (‚Üëk * x))

            rw [‚Üê fact2]

            have : ‚Üëk * (2 * œÄ) = 2 * œÄ * ‚Üëk := by
              ring
            rw [this]

          specialize this N
          push_cast at this

          rw [this]

end ruffle




section œÅ

-- See https://github.com/leanprover-community/sphere-eversion/blob/master/SphereEversion/ToMathlib/Analysis/CutOff.lean
def œÅ : ‚Ñù ‚Üí ‚Ñù := sorry

lemma œÅ_diff : ContDiff ‚Ñù ‚ä§ œÅ := sorry

lemma œÅ_ruffling : EqOn œÅ 0 ruffling := sorry

lemma œÅ_unruffling : EqOn œÅ 1 unruffling := sorry

lemma œÅ_mem : ‚àÄ x, œÅ x ‚àà Icc (0 : ‚Ñù) 1 := sorry

@[simp] lemma rho_zero : œÅ 0 = 0 := sorry

@[simp] lemma rho_one : œÅ 1 = 1 := sorry


end œÅ




/-- A pair of circle immersion satisfiying the assumption of Whitney-Graustein. -/
structure WG_pair where
  Œ≥‚ÇÄ : ‚Ñù ‚Üí ‚ÑÇ
  Œ≥‚ÇÅ : ‚Ñù ‚Üí ‚ÑÇ
  imm_Œ≥‚ÇÄ : CircleImmersion Œ≥‚ÇÄ
  imm_Œ≥‚ÇÅ : CircleImmersion Œ≥‚ÇÅ
  turning_eq : imm_Œ≥‚ÇÄ.turningNumber = imm_Œ≥‚ÇÅ.turningNumber



section œù
variable (p : WG_pair)

def WG_pair.œù (s t : ‚Ñù) := (1 - (œÅ s)) ‚Ä¢ (p.Œ≥‚ÇÄ t) + (œÅ s) ‚Ä¢ p.Œ≥‚ÇÅ t

lemma WG_pair.œù_diff : ContDiff ‚Ñù ‚ä§ (uncurry p.œù) := by
  apply ContDiff.add
  apply ContDiff.smul
  apply ContDiff.sub
  exact contDiff_const
  exact œÅ_diff.comp contDiff_fst
  exact p.imm_Œ≥‚ÇÄ.diff.comp contDiff_snd
  apply ContDiff.smul
  exact œÅ_diff.comp contDiff_fst
  exact p.imm_Œ≥‚ÇÅ.diff.comp contDiff_snd

lemma cont_norm_œù : Continuous (uncurry (fun s t ‚Ü¶ ‚Äñderiv (p.œù s) t‚Äñ)) :=
  (ContDiff.continuous_partial_snd p.œù_diff le_top).norm

lemma pœù : ‚àÄs, Periodic (p.œù s) 1 := by
          intro s x
          unfold WG_pair.œù
          have pŒ≥‚ÇÄ := p.imm_Œ≥‚ÇÄ.per x
          have pŒ≥‚ÇÅ := p.imm_Œ≥‚ÇÅ.per x
          rw [pŒ≥‚ÇÄ]
          rw [pŒ≥‚ÇÅ]

end œù




section Œ∏

variable (p : WG_pair)

def WG_pair.Œ∏‚ÇÄ := p.imm_Œ≥‚ÇÄ.lift

def WG_pair.Œ∏‚ÇÅ := p.imm_Œ≥‚ÇÅ.lift

def WG_pair.Œ∏ (s t : ‚Ñù) := (1 - (œÅ s)) * (p.Œ∏‚ÇÄ t) + (œÅ s) * (p.Œ∏‚ÇÅ t)

lemma WG_pair.Œ∏_diff : ContDiff ‚Ñù ‚ä§ (uncurry p.Œ∏) := by
  apply ContDiff.add
  apply ContDiff.smul
  apply ContDiff.sub
  exact contDiff_const
  exact œÅ_diff.comp contDiff_fst
  exact p.imm_Œ≥‚ÇÄ.contDiff_lift.comp contDiff_snd
  apply ContDiff.smul
  exact œÅ_diff.comp contDiff_fst
  exact p.imm_Œ≥‚ÇÅ.contDiff_lift.comp contDiff_snd

--def B (s t : ‚Ñù) := (deriv (p.Œ∏ s) t) ‚Ä¢ (R ((p.Œ∏ s t) + œÄ / 2) * ruffle t)

end Œ∏



section R


def R : ‚Ñù ‚Üí ‚ÑÇ := fun Œ∏ ‚Ü¶ cexp (Œ∏ ‚Ä¢ I)

lemma dR {p:WG_pair} (s t : ‚Ñù) : deriv (fun (t' : ‚Ñù) ‚Ü¶ R (p.Œ∏ s t')) t = R ((p.Œ∏ s t) + œÄ / 2) * deriv (p.Œ∏ s) t := by sorry


lemma p_R : Periodic R (2*œÄ) := by
          intro x
          unfold R
          have := Complex.exp_periodic (x‚Ä¢ I)
          rw [‚Üê this]
          simp
          have : (‚Üëx + 2 * ‚ÜëœÄ) * I = ‚Üëx * I + 2 * ‚ÜëœÄ * I := by
            ring
          rw [this]


end R



/-
section ABC

variable (p : WG_pair)


section A

def A := fun s t ‚Ü¶ deriv (p.œù s) t
def normA := fun s t ‚Ü¶ ‚Äñ(A p) s t‚Äñ

lemma contA : Continuous (uncurry (normA p)) := (ContDiff.continuous_partial_snd (p.œù_diff) (OrderTop.le_top (1:‚Ñï‚àû))).norm

end A



section B

def B (s t : ‚Ñù) := (deriv (p.Œ∏ s) t) ‚Ä¢ (R ((p.Œ∏ s t) + œÄ / 2) * ruffle t)
def normB := fun s t ‚Ü¶ ‚Äñ(B p) s t‚Äñ



lemma contB : Continuous (uncurry (normB p)) := by
  have c1 := (ContDiff.continuous_partial_snd (p.Œ∏_diff) (OrderTop.le_top (1:‚Ñï‚àû)))
  have c2 : Continuous (fun (x:(‚Ñù√ó‚Ñù)) ‚Ü¶ R ((p.Œ∏ x.1 x.2) + œÄ / 2) * ruffle x.2) := by
    apply Continuous.mul
    apply Continuous.comp
    exact Complex.continuous_exp
    apply Continuous.smul
    apply Continuous.add
    exact ContDiff.continuous p.Œ∏_diff
    exact continuous_const
    exact continuous_const

    rw [duh]
    apply Continuous.add
    apply Continuous.neg
    apply Continuous.comp'
    exact continuous_ofReal
    apply Continuous.comp'
    exact Real.continuous_sin
    apply Continuous.comp
    exact continuous_mul_left (4 * œÄ : ‚Ñù)
    apply Continuous.comp'
    exact continuous_snd
    exact continuous_id'

    apply Continuous.smul
    apply Continuous.comp
    exact continuous_mul_left 2
    apply Continuous.comp'
    exact Real.continuous_sin
    apply Continuous.comp
    exact continuous_mul_left (2 * œÄ : ‚Ñù)
    apply Continuous.comp'
    exact continuous_snd

    exact continuous_id'

    exact continuous_const

  exact (Continuous.smul c1 c2).norm

end B


section C

def WG_pair.C := fun s t ‚Ü¶ (2 * œÄ) ‚Ä¢ (deriv ruffle t * R (p.Œ∏ s t)) --NOTICE NEITHER H NOR N‚ÇÄ IS INCLUDED IN THIS STATEMENT.
def WG_pair.normC := fun s t ‚Ü¶ ‚Äñp.C s t‚Äñ--Im not quite sure how to address this; the underlying argument is that this is true for any nonzero scaling of the t argued to the deriv, and similarly the extrema of ‚ÄñC‚Äñ are also unchanged.

lemma WG_pair.contC : Continuous (uncurry p.normC) := by
  have c1 := ((contDiff_top_iff_deriv.1 (ruffle_diff)).2).continuous

  have c2 : Continuous (uncurry p.Œ∏) := p.Œ∏_diff.continuous

  have c3 : Continuous (fun (x:(‚Ñù√ó‚Ñù)) ‚Ü¶ (2 * œÄ) ‚Ä¢ (deriv ruffle x.2 * R (p.Œ∏ x.1 x.2))) := by
    apply Continuous.smul
    exact continuous_const
    apply Continuous.mul
    apply Continuous.comp'
    exact c1
    exact continuous_snd
    apply Continuous.comp
    exact Complex.continuous_exp
    apply Continuous.smul
    exact c2
    exact continuous_const

  exact c3.norm


end C



end ABC

-/


section WGMain


theorem whitney_graustein {Œ≥‚ÇÄ Œ≥‚ÇÅ : ‚Ñù ‚Üí ‚ÑÇ} {t : ‚Ñù} (imm_Œ≥‚ÇÄ : CircleImmersion Œ≥‚ÇÄ) (imm_Œ≥‚ÇÅ : CircleImmersion Œ≥‚ÇÅ) :
  (imm_Œ≥‚ÇÄ.turningNumber = imm_Œ≥‚ÇÅ.turningNumber) ‚Üí ‚àÉ (Œ≥ : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚ÑÇ), HtpyCircleImmersion Œ≥ ‚àß ((‚àÄ t, Œ≥ 0 t = Œ≥‚ÇÄ t) ‚àß (‚àÄ t, Œ≥ 1 t = Œ≥‚ÇÅ t)) := by
  intro hyp --we want to show that since there exists some N,H pair such that... then there exists...
  let tn := CircleImmersion.turningNumber imm_Œ≥‚ÇÄ

  --rcases (lift_exists imm_Œ≥‚ÇÄ) with ‚ü®(Œ∏‚ÇÄ : ‚Ñù ‚Üí ‚Ñù), hŒ∏‚ÇÄ_lift_is_lift, hŒ∏‚ÇÄ_diff, hŒ∏‚ÇÄ_decomp‚ü©
  --rcases (lift_exists imm_Œ≥‚ÇÅ) with ‚ü®(Œ∏‚ÇÅ : ‚Ñù ‚Üí ‚Ñù), hŒ∏‚ÇÅ_lift_is_lift, hŒ∏‚ÇÅ_diff, hŒ∏‚ÇÅ_decomp‚ü©


  let p:WG_pair := ‚ü®Œ≥‚ÇÄ, Œ≥‚ÇÅ, imm_Œ≥‚ÇÄ, imm_Œ≥‚ÇÅ, hyp‚ü©


  /-A-/

  let A := fun s t ‚Ü¶ deriv (p.œù s) t
  let normA := fun s t ‚Ü¶ ‚ÄñA s t‚Äñ

  have contA : Continuous (uncurry normA) := (ContDiff.continuous_partial_snd (p.œù_diff) (OrderTop.le_top (1:‚Ñï‚àû))).norm

  rcases (unit_compact.prod unit_compact).exists_isMaxOn (unit_nonempty.prod unit_nonempty) contA.continuousOn with
    ‚ü®‚ü®s‚ÇÉ, t‚ÇÉ‚ü©, ‚ü®s‚ÇÉin : s‚ÇÉ ‚àà unit, t‚ÇÉin : t‚ÇÉ ‚àà unit‚ü©, hst‚ÇÉ‚ü©
  let K‚ÇÉ := normA s‚ÇÉ t‚ÇÉ



  /-B-/
  let B (s t : ‚Ñù) := (deriv (p.Œ∏ s) t) ‚Ä¢ (R ((p.Œ∏ s t) + œÄ / 2) * ruffle t)
  let normB := fun s t ‚Ü¶ ‚ÄñB s t‚Äñ



  have contB : Continuous (uncurry normB) := by
    have c1 := (ContDiff.continuous_partial_snd (p.Œ∏_diff) (OrderTop.le_top (1:‚Ñï‚àû)))
    have c2 : Continuous (fun (x:(‚Ñù√ó‚Ñù)) ‚Ü¶ R ((p.Œ∏ x.1 x.2) + œÄ / 2) * ruffle x.2) := by
      apply Continuous.mul
      apply Continuous.comp
      exact Complex.continuous_exp
      apply Continuous.smul
      apply Continuous.add
      exact ContDiff.continuous p.Œ∏_diff
      exact continuous_const
      exact continuous_const

      rw [duh]
      apply Continuous.add
      apply Continuous.neg
      apply Continuous.comp'
      exact continuous_ofReal
      apply Continuous.comp'
      exact Real.continuous_sin
      apply Continuous.comp
      exact continuous_mul_left (4 * œÄ : ‚Ñù)
      apply Continuous.comp'
      exact continuous_snd
      exact continuous_id'

      apply Continuous.smul
      apply Continuous.comp
      exact continuous_mul_left 2
      apply Continuous.comp'
      exact Real.continuous_sin
      apply Continuous.comp
      exact continuous_mul_left (2 * œÄ : ‚Ñù)
      apply Continuous.comp'
      exact continuous_snd

      exact continuous_id'

      exact continuous_const

    exact (Continuous.smul c1 c2).norm


  rcases (unit_compact.prod unit_compact).exists_isMaxOn (unit_nonempty.prod unit_nonempty) contB.continuousOn with
    ‚ü®‚ü®s‚ÇÇ, t‚ÇÇ‚ü©, ‚ü®s‚ÇÇin : s‚ÇÇ ‚àà unit, t‚ÇÇin : t‚ÇÇ ‚àà unit‚ü©, hst‚ÇÇ‚ü©
  let K‚ÇÇ := normB s‚ÇÇ t‚ÇÇ


  /-C-/
  let C := fun s t ‚Ü¶ (2 * œÄ) ‚Ä¢ (deriv ruffle t * R (p.Œ∏ s t)) --NOTICE NEITHER H NOR N‚ÇÄ IS INCLUDED IN THIS STATEMENT.
  let normC := fun s t ‚Ü¶ ‚ÄñC s t‚Äñ--Im not quite sure how to address this; the underlying argument is that this is true for any nonzero scaling of the t argued to the deriv, and similarly the extrema of ‚ÄñC‚Äñ are also unchanged.

  have contC : Continuous (uncurry normC) := by
    have c1 := ((contDiff_top_iff_deriv.1 (ruffle_diff)).2).continuous

    have c2 : Continuous (uncurry p.Œ∏) := p.Œ∏_diff.continuous

    have c3 : Continuous (fun (x:(‚Ñù√ó‚Ñù)) ‚Ü¶ (2 * œÄ) ‚Ä¢ (deriv ruffle x.2 * R (p.Œ∏ x.1 x.2))) := by
      apply Continuous.smul
      exact continuous_const
      apply Continuous.mul
      apply Continuous.comp'
      exact c1
      exact continuous_snd
      apply Continuous.comp
      exact Complex.continuous_exp
      apply Continuous.smul
      exact c2
      exact continuous_const

    exact c3.norm



  rcases (unit_compact.prod unit_compact).exists_isMinOn (unit_nonempty.prod unit_nonempty) contC.continuousOn with
    ‚ü®‚ü®s‚ÇÅ, t‚ÇÅ‚ü©, ‚ü®s‚ÇÅin : s‚ÇÅ ‚àà unit, t‚ÇÅin : t‚ÇÅ ‚àà unit‚ü©, hst‚ÇÅ‚ü©
  let K‚ÇÅ := normC s‚ÇÅ t‚ÇÅ

  /-
  ------------------------------------------------------------------------CHECK IF 2 œÄ SHOULD REALLY BE HERE
  let C := fun s t ‚Ü¶ (2 * œÄ) ‚Ä¢ (deriv ruffle t * R (Œ∏ s t)) --NOTICE NEITHER H NOR N‚ÇÄ IS INCLUDED IN THIS STATEMENT.
  let normC := fun s t ‚Ü¶ ‚ÄñC s t‚Äñ--Im not quite sure how to address this; the underlying argument is that this is true for any nonzero scaling of the t argued to the deriv, and similarly the extrema of ‚ÄñC‚Äñ are also unchanged.

  have cont : Continuous (uncurry normC) := by
    have c1 := ((contDiff_top_iff_deriv.1 (ruffle_diff)).2).continuous

    have c2 : Continuous (uncurry Œ∏) := Œ∏_diff.continuous

    have c3 : Continuous (fun (x:(‚Ñù√ó‚Ñù)) ‚Ü¶ (2 * œÄ) ‚Ä¢ (deriv ruffle x.2 * R (Œ∏ x.1 x.2))) := by
      apply Continuous.smul
      exact continuous_const
      apply Continuous.mul
      apply Continuous.comp'
      exact c1
      exact continuous_snd
      apply Continuous.comp
      exact Complex.continuous_exp
      apply Continuous.smul
      exact c2
      exact continuous_const

    exact c3.norm
-/


  have K‚ÇÅ_pos : K‚ÇÅ > 0 := by
    by_contra opp
    push_neg at opp
    simp only at opp
    have := norm_nonneg ((2 * œÄ) ‚Ä¢ (deriv ruffle t‚ÇÅ * R ((1 - œÅ s‚ÇÅ) * p.Œ∏‚ÇÄ t‚ÇÅ + œÅ s‚ÇÅ * p.Œ∏‚ÇÅ t‚ÇÅ)))
    have opp': ‚Äñ(2 * œÄ) ‚Ä¢ (deriv ruffle t‚ÇÅ * R ((1 - œÅ s‚ÇÅ) * p.Œ∏‚ÇÄ t‚ÇÅ + œÅ s‚ÇÅ * p.Œ∏‚ÇÅ t‚ÇÅ))‚Äñ = 0 := by
      sorry
      --exact LE.le.antisymm opp this
    clear opp this

    rw [norm_smul (2*œÄ) (deriv ruffle t‚ÇÅ * R ((1 - œÅ s‚ÇÅ) * p.Œ∏‚ÇÄ t‚ÇÅ + œÅ s‚ÇÅ * p.Œ∏‚ÇÅ t‚ÇÅ))] at opp'
    apply mul_eq_zero.1 at opp'
    rcases opp' with A|opp
    simp at A
    have : œÄ ‚â† 0 := by
      exact pi_ne_zero
    exact this A

    rw [norm_mul (deriv ruffle t‚ÇÅ) (R ((1 - œÅ s‚ÇÅ) * p.Œ∏‚ÇÄ t‚ÇÅ + œÅ s‚ÇÅ * p.Œ∏‚ÇÅ t‚ÇÅ))] at opp
    apply mul_eq_zero.1 at opp
    rcases opp with B|C

    have := ruffle_deriv_neq_zero_on_unit t‚ÇÅin
    have : ‚Äñderiv ruffle t‚ÇÅ‚Äñ ‚â† 0 := by
      exact norm_ne_zero_iff.mpr this
    exact this B

    unfold R at C
    have : ‚àÄ t:‚Ñù, t*I = t‚Ä¢ I:= by
      intro t
      simp
    specialize this ((1 - œÅ s‚ÇÅ) * p.Œ∏‚ÇÄ t‚ÇÅ + œÅ s‚ÇÅ * p.Œ∏‚ÇÅ t‚ÇÅ)
    have final := Complex.norm_exp_ofReal_mul_I ((1 - œÅ s‚ÇÅ) * p.Œ∏‚ÇÄ t‚ÇÅ + œÅ s‚ÇÅ * p.Œ∏‚ÇÅ t‚ÇÅ)
    rw [this] at final
    rw [final] at C
    linarith


  rcases (root_lemma_maybe K‚ÇÅ K‚ÇÇ K‚ÇÉ K‚ÇÅ_pos H_pos) with ‚ü®N‚ÇÄ, hN‚ÇÄ‚ü©

  --Prove K‚ÇÅ is positive and do the same for H (or set H = 1), get N‚ÇÄ, then N

  let Œ≥ : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚ÑÇ := fun s t ‚Ü¶ p.œù s t + (h s) ‚Ä¢ (R (p.Œ∏ s t) * ruffle ((N‚ÇÄ + 1) * t))
  use Œ≥
  constructor
  --these statements will likely need to be proved out of order, probably starting with the statement of derive_ne
  ¬∑ have dif : ContDiff ‚Ñù ‚ä§ (uncurry Œ≥) := by
      have sufficient : ContDiff ‚Ñù ‚ä§ (fun (x : ‚Ñù √ó ‚Ñù) ‚Ü¶ p.œù x.1 x.2 + (h x.1) ‚Ä¢ (R (p.Œ∏ x.1 x.2) * ruffle ((N‚ÇÄ + 1) * x.2))) := by
        apply ContDiff.add
        exact p.œù_diff
        apply ContDiff.smul
        exact ContDiff.fst' h_diff
        apply ContDiff.mul
        apply ContDiff.comp
        exact Complex.contDiff_exp
        apply ContDiff.smul
        exact p.Œ∏_diff
        exact contDiff_const
        have : ContDiff ‚Ñù ‚ä§ (fun (x : ‚Ñù √ó ‚Ñù) ‚Ü¶ (‚ÜëN‚ÇÄ + 1) * x.2) := by
          apply ContDiff.snd'
          apply ContDiff.mul
          exact contDiff_const
          exact contDiff_id
        have this2 := ruffle_diff
        have fin := ContDiff.comp this2 this
        have duh : (ruffle ‚àò fun (x : ‚Ñù √ó ‚Ñù) ‚Ü¶ (‚ÜëN‚ÇÄ + 1) * x.2) = (fun (x : ‚Ñù √ó ‚Ñù) ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * x.2)) := by
          exact rfl
        rw [duh] at fin
        exact fin
      exact sufficient

    have im : ‚àÄ s, CircleImmersion (Œ≥ s) := by
      intro s
      have cdiff : ContDiff ‚Ñù ‚ä§ (Œ≥ s) := by
        simp only
        apply ContDiff.add
        apply ContDiff.add
        apply ContDiff.smul
        exact contDiff_const
        exact imm_Œ≥‚ÇÄ.diff
        apply ContDiff.smul
        exact contDiff_const
        exact imm_Œ≥‚ÇÅ.diff
        apply ContDiff.smul
        exact contDiff_const
        apply ContDiff.mul
        apply ContDiff.comp
        exact Complex.contDiff_exp
        apply ContDiff.smul
        apply ContDiff.add
        apply ContDiff.mul
        exact contDiff_const

        have := imm_Œ≥‚ÇÄ.contDiff_lift
        have t2 : p.Œ∏‚ÇÄ = (CircleImmersion.lift imm_Œ≥‚ÇÄ) := by
          unfold WG_pair.Œ∏‚ÇÄ
          simp only
        rw [‚Üê t2] at this
        exact this

        apply ContDiff.mul
        exact contDiff_const

        have := imm_Œ≥‚ÇÅ.contDiff_lift
        have t2 : p.Œ∏‚ÇÅ = (CircleImmersion.lift imm_Œ≥‚ÇÅ) := by
          unfold WG_pair.Œ∏‚ÇÅ
          simp only
        rw [‚Üê t2] at this
        exact this

        exact contDiff_const

        have : ContDiff ‚Ñù ‚ä§ (fun (x : ‚Ñù) ‚Ü¶ (‚ÜëN‚ÇÄ + 1) * x) := ContDiff.mul contDiff_const contDiff_id

        have fin := ContDiff.comp ruffle_diff this

        have duh : (ruffle ‚àò fun (x : ‚Ñù) ‚Ü¶ (‚ÜëN‚ÇÄ + 1) * x) = (fun (x : ‚Ñù) ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * x)) := rfl

        rw [duh] at fin
        exact fin


      have periodic : Periodic (Œ≥ s) 1 := by

        unfold Periodic
        intro x
        dsimp only [Œ≥]


        rw [pœù p s x]
        have := p_ruffle (‚ÜëN‚ÇÄ+1) x
        simp at this
        rw [this]

        clear this

        have : R (p.Œ∏ s x) = R (p.Œ∏ s (x+1)) := by
          unfold WG_pair.Œ∏
          have t0 := imm_Œ≥‚ÇÄ.lift_add x 1
          have t1 := imm_Œ≥‚ÇÅ.lift_add x 1

          have eq0: p.Œ∏‚ÇÄ = CircleImmersion.lift imm_Œ≥‚ÇÄ := by
            exact rfl

          have eq1: p.Œ∏‚ÇÅ = CircleImmersion.lift imm_Œ≥‚ÇÅ := by
            exact rfl

          rw [eq0, eq1]
          simp at t0
          simp at t1

          rw [t0,t1]
          rw [hyp]

          have := (Function.Periodic.int_mul p_R (tn)) ((1 - œÅ s) * CircleImmersion.lift imm_Œ≥‚ÇÄ x + œÅ s * CircleImmersion.lift imm_Œ≥‚ÇÅ x)
          rw[‚Üê this]

          have : (1 - œÅ s) * CircleImmersion.lift imm_Œ≥‚ÇÄ x + œÅ s * CircleImmersion.lift imm_Œ≥‚ÇÅ x + ‚Üëtn * (2 * œÄ) = (1 - œÅ s) * (CircleImmersion.lift imm_Œ≥‚ÇÄ x + ‚Üë(CircleImmersion.turningNumber imm_Œ≥‚ÇÅ) * 2 * œÄ) + œÅ s * (CircleImmersion.lift imm_Œ≥‚ÇÅ x + ‚Üë(CircleImmersion.turningNumber imm_Œ≥‚ÇÅ) * 2 * œÄ) := by
            ring_nf
            simp
            rw [hyp]
            rw [mul_comm]
          rw [this]


        rw [‚Üê this]





      have dŒ≥non0 : ‚àÄ t, deriv (Œ≥ s) t ‚â† 0 := by
        intro t
        --gotta split this up by phase, just assume this is the "main phase" proof for now where h s = H for all s
        have subcritical : K‚ÇÅ * H * ‚Üë(N‚ÇÄ + 1) - (K‚ÇÇ * H + K‚ÇÉ) > 0 := hN‚ÇÄ (N‚ÇÄ + 1) (Nat.lt.base N‚ÇÄ) --just so youre aware
        have critical : ‚Äñderiv (Œ≥ s) t‚Äñ ‚â• K‚ÇÅ * (N‚ÇÄ + 1) * H - K‚ÇÇ * H - K‚ÇÉ := sorry --we need this


        have bro_on_god‚ÇÄ : deriv (fun t' ‚Ü¶ (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t') * ruffle ((‚ÜëN‚ÇÄ + 1) * t'))) t = _ := by
          calc
          deriv (fun t' ‚Ü¶ (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t') * ruffle ((‚ÜëN‚ÇÄ + 1) * t'))) t
            = (fun t' ‚Ü¶ R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t')) t * deriv (fun t' ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * t')) t + deriv (fun t' ‚Ü¶ R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t')) t * (fun t' ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * t')) t := by
              rw [deriv_mul]
              exact
                add_comm
                  (deriv (fun t' ‚Ü¶ R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t')) t * ruffle ((‚ÜëN‚ÇÄ + 1) * t))
                  (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) * deriv (fun t' ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * t')) t)

              have d_Œ∏: Differentiable ‚Ñù (p.Œ∏ s) := by
                simp only
                apply Differentiable.add
                apply Differentiable.mul
                exact differentiable_const (1 - œÅ s)
                have := imm_Œ≥‚ÇÄ.contDiff_lift
                have t2 : p.Œ∏‚ÇÄ = (CircleImmersion.lift imm_Œ≥‚ÇÄ) := by
                  unfold WG_pair.Œ∏‚ÇÄ
                  simp only
                rw [‚Üê t2] at this
                have := (this.differentiable (OrderTop.le_top (1:‚Ñï‚àû)))
                exact this
                apply Differentiable.mul
                exact differentiable_const (œÅ s)
                have := imm_Œ≥‚ÇÅ.contDiff_lift
                have t2 : p.Œ∏‚ÇÅ = (CircleImmersion.lift imm_Œ≥‚ÇÅ) := by
                  unfold WG_pair.Œ∏‚ÇÅ
                  simp only
                rw [‚Üê t2] at this
                have this2 := (this.differentiable (OrderTop.le_top (1:‚Ñï‚àû)))
                exact this2
              --have := dR s t

              have : HasDerivAt ((fun t' ‚Ü¶ R (p.Œ∏ s t'))) (R (p.Œ∏ s t + œÄ / 2) * ‚Üë(deriv (p.Œ∏ s) t)) t := by
                sorry -- HOW TO CONVERT DERIV TO HASDERIVAT????

              exact HasDerivAt.differentiableAt this

              have rewrite : (fun t' ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * t')) = ruffle ‚àò (fun t' ‚Ü¶ (‚ÜëN‚ÇÄ + 1) * t') := by
                exact rfl
              rw [rewrite]
              apply DifferentiableAt.comp
              have d_ruff : Differentiable ‚Ñù ruffle := (ruffle_diff.differentiable (OrderTop.le_top (1:‚Ñï‚àû)))
              exact Differentiable.differentiableAt d_ruff
              apply DifferentiableAt.mul

              simp
              simp

          _ = (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t)) * (‚ÜëN‚ÇÄ + 1)) + ((R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t + œÄ / 2) * deriv (p.Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t)) := by --left term is an rfl and a chain rule, right term using dR (up to a hidden rfl and rewriting the statement of dR)

            simp


            have fact1 : deriv (fun t' ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * t')) t = deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t) * (‚ÜëN‚ÇÄ + 1) := by
              have : (fun t' ‚Ü¶ ruffle ((‚ÜëN‚ÇÄ + 1) * t')) = ruffle ‚àò (fun t' ‚Ü¶ ((‚ÜëN‚ÇÄ+1)* t' ) ) := by exact rfl
              rw[this]
              have h1 : DifferentiableAt ‚Ñù ruffle ((N‚ÇÄ + 1) * t) := by sorry

              have h2 : DifferentiableAt ‚Ñù (fun (t':‚Ñù) ‚Ü¶ (N‚ÇÄ + 1) * t') t := by sorry

              sorry





            have fact2 : deriv (fun t' ‚Ü¶ R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t')) t = R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t + œÄ / 2) * ‚Üë(deriv (fun t ‚Ü¶ (1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) t) := by
              have : deriv (fun (t' : ‚Ñù) ‚Ü¶ R (p.Œ∏ s t')) t = R ((p.Œ∏ s t) + œÄ / 2) * deriv (p.Œ∏ s) t := by sorry
              exact this



            rw[fact1,fact2]

            sorry
              --Tactic.RingNF.mul_assoc_rev (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t))
                --(deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t)) (‚ÜëN‚ÇÄ + 1)













          --the norms of each of the above terms are (supposedly) bounded by K‚ÇÅ and K‚ÇÇ respectively. Might need to demonstrate that these terms are identical to the things in those statements
        have bro_on_god‚ÇÅ : deriv (Œ≥ s) t = (((1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t) + (‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t)) + ‚Üë(h s) * (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t)) * (‚ÜëN‚ÇÄ + 1)) + ‚Üë(h s) * ((R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t + œÄ / 2) * deriv (p.Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t)) := by
          calc
          deriv (Œ≥ s) t = deriv (fun t' ‚Ü¶ p.œù s t' + (h s) ‚Ä¢ (R (p.Œ∏ s t') * ruffle ((N‚ÇÄ + 1) * t'))) t := rfl
          _ = deriv (fun t' ‚Ü¶ (1 - ‚Üë(œÅ s)) * Œ≥‚ÇÄ t') t + deriv (fun t' ‚Ü¶ ‚Üë(œÅ s) * Œ≥‚ÇÅ t') t + deriv (fun t' ‚Ü¶ ‚Üë(h s) * (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t') * ruffle ((‚ÜëN‚ÇÄ + 1) * t'))) t := by --rw deriv_add _ _ twice i think or rw with linearity to cover several lines if thats a thing we can do
              /-rw [deriv_add]

              unfold WG_pair.Œ∏

              rw [deriv_add]
              simp

              apply DifferentiableAt.smul
              exact differentiableAt_const (1 - œÅ s)
              have := (imm_Œ≥‚ÇÄ.diff.differentiable (OrderTop.le_top (1:‚Ñï‚àû)))
              have :DifferentiableAt ‚Ñù Œ≥‚ÇÄ t := Differentiable.differentiableAt this
              exact this
              apply DifferentiableAt.smul
              exact differentiableAt_const (œÅ s)
              have := (imm_Œ≥‚ÇÅ.diff.differentiable (OrderTop.le_top (1:‚Ñï‚àû)))
              have :DifferentiableAt ‚Ñù Œ≥‚ÇÅ t := Differentiable.differentiableAt this
              exact this

              have : HasDerivAt (œù s) ((1 - œÅ s) ‚Ä¢ deriv Œ≥‚ÇÄ t + œÅ s ‚Ä¢ deriv Œ≥‚ÇÅ t) t := by
                sorry --USE dœù???????

              exact HasDerivAt.differentiableAt this
              apply DifferentiableAt.smul
              exact differentiableAt_const (h s)
              apply DifferentiableAt.mul

              /-

              These last two goals look identical to some goals in bro_on_god‚ÇÄ.
              Maybe we should take those out as larger lemmas and reuse.
              It's all about deriv ‚Üí HasDerivAt ‚Üí DifferentiableAt

              -/
              sorry-/
              sorry






          _ = ((1 - ‚Üë(œÅ s)) * deriv (fun t' ‚Ü¶ Œ≥‚ÇÄ t') t) + (‚Üë(œÅ s) * deriv (fun t' ‚Ü¶ Œ≥‚ÇÅ t') t) + (‚Üë(h s) * deriv (fun t' ‚Ü¶ (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t') * ruffle ((‚ÜëN‚ÇÄ + 1) * t'))) t) := by --pulling out a complex constant thrice
              rw [deriv_mul]
              rw [deriv_const, zero_mul, zero_add]
              rw [deriv_mul]
              rw [deriv_const, zero_mul, zero_add]
              rw [deriv_mul]
              rw [deriv_const, zero_mul, zero_add]


              /-
              SAME DIFFERENITABLEAT THINGS AS BEFORE
              -/
              sorry
              sorry
              sorry
              sorry
              sorry
              sorry


          _ = (((1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t) + (‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t)) + (‚Üë(h s) * deriv (fun t' ‚Ü¶ (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t' + œÅ s * p.Œ∏‚ÇÅ t') * ruffle ((‚ÜëN‚ÇÄ + 1) * t'))) t) := by--associating A
              exact rfl

          _ = (((1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t) + (‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t)) + ‚Üë(h s) * (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t)) * (‚ÜëN‚ÇÄ + 1)) + ‚Üë(h s) * ((R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t + œÄ / 2) * deriv (p.Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t)) := by--using the identity from bro_on_god‚ÇÄ
              rw[bro_on_god‚ÇÄ]

              simp
              sorry




        /-
        have ff : ‚Äñ((1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t + ‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t) + ‚Üë(h s) * (R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t + œÄ / 2) * deriv (Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t) + ‚Üë(h s) * R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t) * deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t) * (‚ÜëN‚ÇÄ + 1)‚Äñ > 0 := by
          calc--oh RIP I think I have to write this backwards (so that H shows up on both terms rather than just one)
          ‚Äñ((1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t + ‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t) + ‚Üë(h s) * (R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t + œÄ / 2) * deriv (Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t) + ‚Üë(h s) * R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t) * deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t) * (‚ÜëN‚ÇÄ + 1)‚Äñ
            ‚â• ‚Äñ‚Üë(h s) * R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t)) * (‚ÜëN‚ÇÄ + 1)‚Äñ - ‚Äñ‚Üë(h s) * (R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t + œÄ / 2) * deriv (Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t)‚Äñ - ‚Äñ(1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t + ‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t‚Äñ := in_particular
          _ = ‚Äñ‚Üë(h s) * R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t)) * (‚ÜëN‚ÇÄ + 1)‚Äñ - ‚Äñ‚Üë(h s) * (R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t + œÄ / 2) * deriv (Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t)‚Äñ - ‚Äñ‚Üë(deriv (œù s) t)‚Äñ := sorry --by rw [dœù s t] + a few coercion things on the last term
          _ ‚â• ‚Äñ‚Üë(h s) * R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t)) * (‚ÜëN‚ÇÄ + 1)‚Äñ - ‚Äñ‚Üë(h s) * (R ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t + œÄ / 2) * deriv (Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t)‚Äñ - K‚ÇÉ := sorry --im not sure if weve addressed how to require the computation is true on the unit, but in this case it really is totally bounded
          _ = ‚Äñ‚Üë(h s)‚Äñ * ‚Äñ((‚ÜëN‚ÇÄ : ‚ÑÇ) + 1)‚Äñ * ‚ÄñR ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t))‚Äñ - ‚Äñ‚Üë(h s)‚Äñ * ‚ÄñR ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t + œÄ / 2) * deriv (Œ∏ s) t * ruffle ((‚ÜëN‚ÇÄ + 1) * t)‚Äñ - K‚ÇÉ := sorry --splitting along multiplications of h and n components
          _ = H * (‚ÜëN‚ÇÄ + 1 : ‚Ñù) * ‚ÄñR ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t) * (deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t))‚Äñ - H * ‚ÄñR ((1 - œÅ s) * Œ∏‚ÇÄ t + œÅ s * Œ∏‚ÇÅ t + œÄ / 2) * deriv (Œ∏ s) t * ruffle ((‚ÜëN‚ÇÄ + 1) * t)‚Äñ - K‚ÇÉ := sorry --addressing ‚Äñ((‚ÜëN‚ÇÄ : ‚ÑÇ) + 1)‚Äñ and h s in the main phase
          _ ‚â• H * (‚ÜëN‚ÇÄ + 1 : ‚Ñù) * K‚ÇÉ - H * K‚ÇÇ - K‚ÇÉ := sorry --the boundings
          _ > 0 := sorry --rearrange subcritical
          -/

        have ff : ‚Äñ(1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t + ‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t + ‚Üë(h s) * (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) * deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t) * (‚ÜëN‚ÇÄ + 1)) + ‚Üë(h s) * (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t + œÄ / 2) * ‚Üë(deriv (p.Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t))‚Äñ > 0 := by
          let N:‚Ñï := (N‚ÇÄ) +1
          let A := (1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t + ‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t
          let B := ‚Üë(h s) * R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t + œÄ / 2) * ‚Üë(deriv (p.Œ∏ s) t) * ruffle (N * t)
          let C := ‚Üë(h s) * R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) * deriv ruffle (N * t) * N


          calc
          ‚Äñ(1 - ‚Üë(œÅ s)) * deriv Œ≥‚ÇÄ t + ‚Üë(œÅ s) * deriv Œ≥‚ÇÅ t + ‚Üë(h s) * (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t) * deriv ruffle ((‚ÜëN‚ÇÄ + 1) * t) * (‚ÜëN‚ÇÄ + 1)) + ‚Üë(h s) * (R ((1 - œÅ s) * p.Œ∏‚ÇÄ t + œÅ s * p.Œ∏‚ÇÅ t + œÄ / 2) * ‚Üë(deriv (p.Œ∏ s) t) * ruffle ((‚ÜëN‚ÇÄ + 1) * t))‚Äñ
            = ‚ÄñA+B+C‚Äñ  := by sorry
          _ ‚â• ‚ÄñC‚Äñ-‚ÄñB‚Äñ-‚ÄñA‚Äñ := in_particular
          _ ‚â• H * N * K‚ÇÅ - H * K‚ÇÇ - K‚ÇÉ := by sorry
          _ > 0 := by
            have : N > N‚ÇÄ := by simp
            have := hN‚ÇÄ N (this)
            have duh : K‚ÇÅ * H * ‚ÜëN - (K‚ÇÇ * H + K‚ÇÉ) = H * ‚ÜëN * K‚ÇÅ - H * K‚ÇÇ - K‚ÇÉ := by
              ring
            rw [‚Üê duh]
            exact this







        have f : ‚Äñderiv (Œ≥ s) t‚Äñ > 0 := by
          rw [bro_on_god‚ÇÅ]
          exact ff

        exact ne_zero_of_map (ne_of_gt f)

        --expanding in preparation for a rewrite
        --then develop the facts that the norm of each term is appropriately related to each K
        --then below apply the rewrites, triangle inequality, bing bang boom you gottem
        --also you might need a little commutativity/associativity inside the norm to translate between facts here

      exact { diff := cdiff, per := periodic, deriv_ne := dŒ≥non0 }

    exact { diff := dif, imm := im }

  ¬∑ constructor
    ¬∑ intro t
      simp
      unfold WG_pair.œù
      simp

    ¬∑ intro t
      simp
      unfold WG_pair.œù
      simp



end WGMain
end WhitneyGraustein
--apparently there is an unterminated comment somewhere; I searched briefly, could not find.
